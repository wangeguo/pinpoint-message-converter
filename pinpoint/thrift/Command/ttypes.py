#
# Autogenerated by Thrift Compiler (0.18.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class TThreadDumpType(object):
    TARGET = 0
    PENDING = 1

    _VALUES_TO_NAMES = {
        0: "TARGET",
        1: "PENDING",
    }

    _NAMES_TO_VALUES = {
        "TARGET": 0,
        "PENDING": 1,
    }


class TThreadState(object):
    NEW = 0
    RUNNABLE = 1
    BLOCKED = 2
    WAITING = 3
    TIMED_WAITING = 4
    TERMINATED = 5

    _VALUES_TO_NAMES = {
        0: "NEW",
        1: "RUNNABLE",
        2: "BLOCKED",
        3: "WAITING",
        4: "TIMED_WAITING",
        5: "TERMINATED",
    }

    _NAMES_TO_VALUES = {
        "NEW": 0,
        "RUNNABLE": 1,
        "BLOCKED": 2,
        "WAITING": 3,
        "TIMED_WAITING": 4,
        "TERMINATED": 5,
    }


class TRouteResult(object):
    OK = 0
    BAD_REQUEST = 200
    EMPTY_REQUEST = 201
    NOT_SUPPORTED_REQUEST = 202
    BAD_RESPONSE = 210
    EMPTY_RESPONSE = 211
    NOT_SUPPORTED_RESPONSE = 212
    TIMEOUT = 220
    NOT_FOUND = 230
    NOT_ACCEPTABLE = 240
    NOT_SUPPORTED_SERVICE = 241
    UNKNOWN = -1

    _VALUES_TO_NAMES = {
        0: "OK",
        200: "BAD_REQUEST",
        201: "EMPTY_REQUEST",
        202: "NOT_SUPPORTED_REQUEST",
        210: "BAD_RESPONSE",
        211: "EMPTY_RESPONSE",
        212: "NOT_SUPPORTED_RESPONSE",
        220: "TIMEOUT",
        230: "NOT_FOUND",
        240: "NOT_ACCEPTABLE",
        241: "NOT_SUPPORTED_SERVICE",
        -1: "UNKNOWN",
    }

    _NAMES_TO_VALUES = {
        "OK": 0,
        "BAD_REQUEST": 200,
        "EMPTY_REQUEST": 201,
        "NOT_SUPPORTED_REQUEST": 202,
        "BAD_RESPONSE": 210,
        "EMPTY_RESPONSE": 211,
        "NOT_SUPPORTED_RESPONSE": 212,
        "TIMEOUT": 220,
        "NOT_FOUND": 230,
        "NOT_ACCEPTABLE": 240,
        "NOT_SUPPORTED_SERVICE": 241,
        "UNKNOWN": -1,
    }


class TCommandThreadDump(object):
    """
    Attributes:
     - type
     - name
     - pendingTimeMillis

    """


    def __init__(self, type=    0, name=None, pendingTimeMillis=None,):
        self.type = type
        self.name = name
        self.pendingTimeMillis = pendingTimeMillis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.pendingTimeMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCommandThreadDump')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.pendingTimeMillis is not None:
            oprot.writeFieldBegin('pendingTimeMillis', TType.I64, 3)
            oprot.writeI64(self.pendingTimeMillis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMonitorInfo(object):
    """
    Attributes:
     - stackDepth
     - stackFrame

    """


    def __init__(self, stackDepth=None, stackFrame=None,):
        self.stackDepth = stackDepth
        self.stackFrame = stackFrame

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.stackDepth = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.stackFrame = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMonitorInfo')
        if self.stackDepth is not None:
            oprot.writeFieldBegin('stackDepth', TType.I32, 1)
            oprot.writeI32(self.stackDepth)
            oprot.writeFieldEnd()
        if self.stackFrame is not None:
            oprot.writeFieldBegin('stackFrame', TType.STRING, 2)
            oprot.writeString(self.stackFrame.encode('utf-8') if sys.version_info[0] == 2 else self.stackFrame)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.stackDepth is None:
            raise TProtocolException(message='Required field stackDepth is unset!')
        if self.stackFrame is None:
            raise TProtocolException(message='Required field stackFrame is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TThreadDump(object):
    """
    Attributes:
     - threadName
     - threadId
     - blockedTime
     - blockedCount
     - waitedTime
     - waitedCount
     - lockName
     - lockOwnerId
     - lockOwnerName
     - inNative
     - suspended
     - threadState
     - stackTrace
     - lockedMonitors
     - lockedSynchronizers

    """


    def __init__(self, threadName=None, threadId=None, blockedTime=None, blockedCount=None, waitedTime=None, waitedCount=None, lockName=None, lockOwnerId=None, lockOwnerName=None, inNative=None, suspended=None, threadState=None, stackTrace=None, lockedMonitors=None, lockedSynchronizers=None,):
        self.threadName = threadName
        self.threadId = threadId
        self.blockedTime = blockedTime
        self.blockedCount = blockedCount
        self.waitedTime = waitedTime
        self.waitedCount = waitedCount
        self.lockName = lockName
        self.lockOwnerId = lockOwnerId
        self.lockOwnerName = lockOwnerName
        self.inNative = inNative
        self.suspended = suspended
        self.threadState = threadState
        self.stackTrace = stackTrace
        self.lockedMonitors = lockedMonitors
        self.lockedSynchronizers = lockedSynchronizers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.threadName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.threadId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.blockedTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.blockedCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.waitedTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.waitedCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.lockName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.lockOwnerId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.lockOwnerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.inNative = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.suspended = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.threadState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.stackTrace = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.stackTrace.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.lockedMonitors = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = TMonitorInfo()
                        _elem11.read(iprot)
                        self.lockedMonitors.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.LIST:
                    self.lockedSynchronizers = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.lockedSynchronizers.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TThreadDump')
        if self.threadName is not None:
            oprot.writeFieldBegin('threadName', TType.STRING, 1)
            oprot.writeString(self.threadName.encode('utf-8') if sys.version_info[0] == 2 else self.threadName)
            oprot.writeFieldEnd()
        if self.threadId is not None:
            oprot.writeFieldBegin('threadId', TType.I64, 2)
            oprot.writeI64(self.threadId)
            oprot.writeFieldEnd()
        if self.blockedTime is not None:
            oprot.writeFieldBegin('blockedTime', TType.I64, 3)
            oprot.writeI64(self.blockedTime)
            oprot.writeFieldEnd()
        if self.blockedCount is not None:
            oprot.writeFieldBegin('blockedCount', TType.I64, 4)
            oprot.writeI64(self.blockedCount)
            oprot.writeFieldEnd()
        if self.waitedTime is not None:
            oprot.writeFieldBegin('waitedTime', TType.I64, 5)
            oprot.writeI64(self.waitedTime)
            oprot.writeFieldEnd()
        if self.waitedCount is not None:
            oprot.writeFieldBegin('waitedCount', TType.I64, 6)
            oprot.writeI64(self.waitedCount)
            oprot.writeFieldEnd()
        if self.lockName is not None:
            oprot.writeFieldBegin('lockName', TType.STRING, 7)
            oprot.writeString(self.lockName.encode('utf-8') if sys.version_info[0] == 2 else self.lockName)
            oprot.writeFieldEnd()
        if self.lockOwnerId is not None:
            oprot.writeFieldBegin('lockOwnerId', TType.I64, 8)
            oprot.writeI64(self.lockOwnerId)
            oprot.writeFieldEnd()
        if self.lockOwnerName is not None:
            oprot.writeFieldBegin('lockOwnerName', TType.STRING, 9)
            oprot.writeString(self.lockOwnerName.encode('utf-8') if sys.version_info[0] == 2 else self.lockOwnerName)
            oprot.writeFieldEnd()
        if self.inNative is not None:
            oprot.writeFieldBegin('inNative', TType.BOOL, 10)
            oprot.writeBool(self.inNative)
            oprot.writeFieldEnd()
        if self.suspended is not None:
            oprot.writeFieldBegin('suspended', TType.BOOL, 11)
            oprot.writeBool(self.suspended)
            oprot.writeFieldEnd()
        if self.threadState is not None:
            oprot.writeFieldBegin('threadState', TType.I32, 12)
            oprot.writeI32(self.threadState)
            oprot.writeFieldEnd()
        if self.stackTrace is not None:
            oprot.writeFieldBegin('stackTrace', TType.LIST, 13)
            oprot.writeListBegin(TType.STRING, len(self.stackTrace))
            for iter18 in self.stackTrace:
                oprot.writeString(iter18.encode('utf-8') if sys.version_info[0] == 2 else iter18)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lockedMonitors is not None:
            oprot.writeFieldBegin('lockedMonitors', TType.LIST, 14)
            oprot.writeListBegin(TType.STRUCT, len(self.lockedMonitors))
            for iter19 in self.lockedMonitors:
                iter19.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lockedSynchronizers is not None:
            oprot.writeFieldBegin('lockedSynchronizers', TType.LIST, 15)
            oprot.writeListBegin(TType.STRING, len(self.lockedSynchronizers))
            for iter20 in self.lockedSynchronizers:
                oprot.writeString(iter20.encode('utf-8') if sys.version_info[0] == 2 else iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.threadName is None:
            raise TProtocolException(message='Required field threadName is unset!')
        if self.threadId is None:
            raise TProtocolException(message='Required field threadId is unset!')
        if self.blockedTime is None:
            raise TProtocolException(message='Required field blockedTime is unset!')
        if self.blockedCount is None:
            raise TProtocolException(message='Required field blockedCount is unset!')
        if self.waitedTime is None:
            raise TProtocolException(message='Required field waitedTime is unset!')
        if self.waitedCount is None:
            raise TProtocolException(message='Required field waitedCount is unset!')
        if self.lockName is None:
            raise TProtocolException(message='Required field lockName is unset!')
        if self.lockOwnerId is None:
            raise TProtocolException(message='Required field lockOwnerId is unset!')
        if self.lockOwnerName is None:
            raise TProtocolException(message='Required field lockOwnerName is unset!')
        if self.inNative is None:
            raise TProtocolException(message='Required field inNative is unset!')
        if self.suspended is None:
            raise TProtocolException(message='Required field suspended is unset!')
        if self.threadState is None:
            raise TProtocolException(message='Required field threadState is unset!')
        if self.stackTrace is None:
            raise TProtocolException(message='Required field stackTrace is unset!')
        if self.lockedMonitors is None:
            raise TProtocolException(message='Required field lockedMonitors is unset!')
        if self.lockedSynchronizers is None:
            raise TProtocolException(message='Required field lockedSynchronizers is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCommandThreadDumpResponse(object):
    """
    Attributes:
     - threadDumps

    """


    def __init__(self, threadDumps=None,):
        self.threadDumps = threadDumps

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.threadDumps = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = TThreadDump()
                        _elem26.read(iprot)
                        self.threadDumps.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCommandThreadDumpResponse')
        if self.threadDumps is not None:
            oprot.writeFieldBegin('threadDumps', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.threadDumps))
            for iter27 in self.threadDumps:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.threadDumps is None:
            raise TProtocolException(message='Required field threadDumps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCmdActiveThreadCount(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCmdActiveThreadCount')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCmdActiveThreadCountRes(object):
    """
    Attributes:
     - histogramSchemaType
     - activeThreadCount
     - timeStamp

    """


    def __init__(self, histogramSchemaType=None, activeThreadCount=None, timeStamp=None,):
        self.histogramSchemaType = histogramSchemaType
        self.activeThreadCount = activeThreadCount
        self.timeStamp = timeStamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.histogramSchemaType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.activeThreadCount = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readI32()
                        self.activeThreadCount.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCmdActiveThreadCountRes')
        if self.histogramSchemaType is not None:
            oprot.writeFieldBegin('histogramSchemaType', TType.I32, 1)
            oprot.writeI32(self.histogramSchemaType)
            oprot.writeFieldEnd()
        if self.activeThreadCount is not None:
            oprot.writeFieldBegin('activeThreadCount', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.activeThreadCount))
            for iter34 in self.activeThreadCount:
                oprot.writeI32(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timeStamp is not None:
            oprot.writeFieldBegin('timeStamp', TType.I64, 3)
            oprot.writeI64(self.timeStamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.histogramSchemaType is None:
            raise TProtocolException(message='Required field histogramSchemaType is unset!')
        if self.activeThreadCount is None:
            raise TProtocolException(message='Required field activeThreadCount is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TActiveThreadDump(object):
    """
    Attributes:
     - execTime
     - threadDump

    """


    def __init__(self, execTime=None, threadDump=None,):
        self.execTime = execTime
        self.threadDump = threadDump

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.execTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.threadDump = TThreadDump()
                    self.threadDump.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TActiveThreadDump')
        if self.execTime is not None:
            oprot.writeFieldBegin('execTime', TType.I64, 1)
            oprot.writeI64(self.execTime)
            oprot.writeFieldEnd()
        if self.threadDump is not None:
            oprot.writeFieldBegin('threadDump', TType.STRUCT, 2)
            self.threadDump.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.execTime is None:
            raise TProtocolException(message='Required field execTime is unset!')
        if self.threadDump is None:
            raise TProtocolException(message='Required field threadDump is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCmdActiveThreadDump(object):
    """
    Attributes:
     - execTime

    """


    def __init__(self, execTime=None,):
        self.execTime = execTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.execTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCmdActiveThreadDump')
        if self.execTime is not None:
            oprot.writeFieldBegin('execTime', TType.I64, 1)
            oprot.writeI64(self.execTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCmdActiveThreadDumpRes(object):
    """
    Attributes:
     - threadDumps

    """


    def __init__(self, threadDumps=None,):
        self.threadDumps = threadDumps

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.threadDumps = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = TActiveThreadDump()
                        _elem40.read(iprot)
                        self.threadDumps.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCmdActiveThreadDumpRes')
        if self.threadDumps is not None:
            oprot.writeFieldBegin('threadDumps', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.threadDumps))
            for iter41 in self.threadDumps:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.threadDumps is None:
            raise TProtocolException(message='Required field threadDumps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCommandEcho(object):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCommandEcho')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCommandTransfer(object):
    """
    Attributes:
     - applicationName
     - agentId
     - startTime
     - payload

    """


    def __init__(self, applicationName=None, agentId=None, startTime=None, payload=None,):
        self.applicationName = applicationName
        self.agentId = agentId
        self.startTime = startTime
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.applicationName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.agentId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.payload = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCommandTransfer')
        if self.applicationName is not None:
            oprot.writeFieldBegin('applicationName', TType.STRING, 1)
            oprot.writeString(self.applicationName.encode('utf-8') if sys.version_info[0] == 2 else self.applicationName)
            oprot.writeFieldEnd()
        if self.agentId is not None:
            oprot.writeFieldBegin('agentId', TType.STRING, 2)
            oprot.writeString(self.agentId.encode('utf-8') if sys.version_info[0] == 2 else self.agentId)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 3)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRING, 4)
            oprot.writeBinary(self.payload)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.applicationName is None:
            raise TProtocolException(message='Required field applicationName is unset!')
        if self.agentId is None:
            raise TProtocolException(message='Required field agentId is unset!')
        if self.payload is None:
            raise TProtocolException(message='Required field payload is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCommandTransferResponse(object):
    """
    Attributes:
     - routeResult
     - payload
     - message

    """


    def __init__(self, routeResult=None, payload=None, message=None,):
        self.routeResult = routeResult
        self.payload = payload
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.routeResult = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.payload = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCommandTransferResponse')
        if self.routeResult is not None:
            oprot.writeFieldBegin('routeResult', TType.I32, 1)
            oprot.writeI32(self.routeResult)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRING, 2)
            oprot.writeBinary(self.payload)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 3)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.routeResult is None:
            raise TProtocolException(message='Required field routeResult is unset!')
        if self.payload is None:
            raise TProtocolException(message='Required field payload is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TCommandThreadDump)
TCommandThreadDump.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None,     0, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I64, 'pendingTimeMillis', None, None, ),  # 3
)
all_structs.append(TMonitorInfo)
TMonitorInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'stackDepth', None, None, ),  # 1
    (2, TType.STRING, 'stackFrame', 'UTF8', None, ),  # 2
)
all_structs.append(TThreadDump)
TThreadDump.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'threadName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'threadId', None, None, ),  # 2
    (3, TType.I64, 'blockedTime', None, None, ),  # 3
    (4, TType.I64, 'blockedCount', None, None, ),  # 4
    (5, TType.I64, 'waitedTime', None, None, ),  # 5
    (6, TType.I64, 'waitedCount', None, None, ),  # 6
    (7, TType.STRING, 'lockName', 'UTF8', None, ),  # 7
    (8, TType.I64, 'lockOwnerId', None, None, ),  # 8
    (9, TType.STRING, 'lockOwnerName', 'UTF8', None, ),  # 9
    (10, TType.BOOL, 'inNative', None, None, ),  # 10
    (11, TType.BOOL, 'suspended', None, None, ),  # 11
    (12, TType.I32, 'threadState', None, None, ),  # 12
    (13, TType.LIST, 'stackTrace', (TType.STRING, 'UTF8', False), None, ),  # 13
    (14, TType.LIST, 'lockedMonitors', (TType.STRUCT, [TMonitorInfo, None], False), None, ),  # 14
    (15, TType.LIST, 'lockedSynchronizers', (TType.STRING, 'UTF8', False), None, ),  # 15
)
all_structs.append(TCommandThreadDumpResponse)
TCommandThreadDumpResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'threadDumps', (TType.STRUCT, [TThreadDump, None], False), None, ),  # 1
)
all_structs.append(TCmdActiveThreadCount)
TCmdActiveThreadCount.thrift_spec = (
)
all_structs.append(TCmdActiveThreadCountRes)
TCmdActiveThreadCountRes.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'histogramSchemaType', None, None, ),  # 1
    (2, TType.LIST, 'activeThreadCount', (TType.I32, None, False), None, ),  # 2
    (3, TType.I64, 'timeStamp', None, None, ),  # 3
)
all_structs.append(TActiveThreadDump)
TActiveThreadDump.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'execTime', None, None, ),  # 1
    (2, TType.STRUCT, 'threadDump', [TThreadDump, None], None, ),  # 2
)
all_structs.append(TCmdActiveThreadDump)
TCmdActiveThreadDump.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'execTime', None, None, ),  # 1
)
all_structs.append(TCmdActiveThreadDumpRes)
TCmdActiveThreadDumpRes.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'threadDumps', (TType.STRUCT, [TActiveThreadDump, None], False), None, ),  # 1
)
all_structs.append(TCommandEcho)
TCommandEcho.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TCommandTransfer)
TCommandTransfer.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'applicationName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'agentId', 'UTF8', None, ),  # 2
    (3, TType.I64, 'startTime', None, None, ),  # 3
    (4, TType.STRING, 'payload', 'BINARY', None, ),  # 4
)
all_structs.append(TCommandTransferResponse)
TCommandTransferResponse.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'routeResult', None, None, ),  # 1
    (2, TType.STRING, 'payload', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'message', 'UTF8', None, ),  # 3
)
fix_spec(all_structs)
del all_structs
